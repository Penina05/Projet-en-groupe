import unittest
from unittest.mock import MagicMock, patch
import math

# ============================
# MOCKS pour ADC et Pin
# ============================

class MockADC:
    def __init__(self, pin, value=0):
        self.pin = pin
        self._value = value

    def read_u16(self):
        return self._value

    def set_value(self, v):
        self._value = v


class MockPin:
    def __init__(self, num):
        self.num = num


# ============================
# Calibration
# ============================

L1 = 100
L2 = 100

X_max = L1 + L2  # 200 mm
Y_max = L1 + L2  # 200 mm

# Coefficients fictifs pour calibration
A_X, B_X = 1.0, 0.0
A_Y, B_Y = 1.0, 0.0

pot_x = MockADC(MockPin(26))
pot_y = MockADC(MockPin(27))


def lire_adc_moyenne(adc, n=10):
    total = 0
    for _ in range(n):
        total += adc.read_u16()
    return total // n


def calibration_xy():
    adc_x = lire_adc_moyenne(pot_x)
    adc_y = lire_adc_moyenne(pot_y)
    x = A_X * adc_x + B_X
    y = A_Y * adc_y + B_Y
    return x, y


def adc_to_mm(adc_value, max_distance):
    return (adc_value / 65535.0) * max_distance


def valeur_potentiometre():
    adc_x = pot_x.read_u16()
    adc_y = pot_y.read_u16()
    X_user = adc_to_mm(adc_x, X_max)
    Y_user = adc_to_mm(adc_y, Y_max)
    return X_user, Y_user


# ============================
# Cinématique inverse
# ============================

def cinematics_inverse(x_user, y_user):
    d = math.sqrt(x_user ** 2 + y_user ** 2)

    if d > (L1 + L2):
        raise ValueError("Position trop éloignée")

    if d < abs(L1 - L2) or d == 0:
        raise ValueError("Position trop proche")

    # Loi des cosinus
    cos_coude = (L1 ** 2 + L2 ** 2 - d ** 2) / (2 * L1 * L2)
    coude = math.degrees(math.acos(cos_coude))

    cos_epaule = (d ** 2 + L1 ** 2 - L2 ** 2) / (2 * L1 * d)
    epaule = math.degrees(math.acos(cos_epaule))

    return epaule, coude


# ============================
# Contrôle des moteurs (PWM)
# ============================

class MockPWM:
    def __init__(self, pin):
        self.pin = pin
        self.freq_value = None
        self.duty_value = None

    def freq(self, f):
        self.freq_value = f

    def duty_u16(self, duty):
        self.duty_value = duty


servo_epaule = MockPWM(MockPin(0))
servo_coude = MockPWM(MockPin(1))
servo_stylo = MockPWM(MockPin(2))

servo_epaule.freq(50)
servo_coude.freq(50)
servo_stylo.freq(50)


def angle_to_pwm(angle):
    if angle < 0:
        angle = 0
    if angle > 180:
        angle = 180
    pulse_ms = 1 + (angle / 180.0) * 1.0
    duty = int((pulse_ms / 20.0) * 65535)
    return duty


def move_servos(angle_epaule, angle_coude, stylo_on=False):
    servo_epaule.duty_u16(angle_to_pwm(angle_epaule))
    servo_coude.duty_u16(angle_to_pwm(angle_coude))
    if stylo_on:
        servo_stylo.duty_u16(angle_to_pwm(90))
    else:
        servo_stylo.duty_u16(angle_to_pwm(0))


# ============================
# UNITTESTS
# ============================

class TestCalibrationXY(unittest.TestCase):

    @patch("__main__.pot_x")
    @patch("__main__.pot_y")
    def test_lire_adc_moyenne(self, mock_pot_y, mock_pot_x):
        mock_adc = MagicMock()
        mock_adc.read_u16.return_value = 20000
        result = lire_adc_moyenne(mock_adc, n=10)
        self.assertEqual(result, 20000)

    @patch("__main__.lire_adc_moyenne")
    def test_calibration_xy(self, mock_lire):
        mock_lire.side_effect = [15000, 30000]
        expected_x = A_X * 15000 + B_X
        expected_y = A_Y * 30000 + B_Y
        x, y = calibration_xy()
        self.assertAlmostEqual(x, expected_x)
        self.assertAlmostEqual(y, expected_y)

    @patch("__main__.lire_adc_moyenne")
    def test_calibration_xy_boundaries(self, mock_lire):
        mock_lire.side_effect = [0, 65535]
        expected_x = A_X * 0 + B_X
        expected_y = A_Y * 65535 + B_Y
        x, y = calibration_xy()
        self.assertAlmostEqual(x, expected_x)
        self.assertAlmostEqual(y, expected_y)


class TestCinematicsInverse(unittest.TestCase):

    def test_basic_position(self):
        epaule, coude = cinematics_inverse(150, 0)
        self.assertTrue(0 <= epaule <= 180)
        self.assertTrue(0 <= coude <= 180)

    def test_unreachable_far(self):
        with self.assertRaises(ValueError):
            cinematics_inverse(500, 500)

    def test_unreachable_near(self):
        with self.assertRaises(ValueError):
            cinematics_inverse(0, 0)

    def test_angle_limits(self):
        epaule, coude = cinematics_inverse(180, 50)
        self.assertGreaterEqual(epaule, 0)
        self.assertLessEqual(epaule, 180)
        self.assertGreaterEqual(coude, 0)
        self.assertLessEqual(coude, 180)

    def test_precision(self):
        ep1, cd1 = cinematics_inverse(180, 80)
        ep2, cd2 = cinematics_inverse(181, 80)
        self.assertLess(abs(ep1 - ep2), 5)
        self.assertLess(abs(cd1 - cd2), 5)


class TestMotorControl(unittest.TestCase):

    def test_angle_zero(self):
        duty = angle_to_pwm(0)
        expected = int((1 / 20) * 65535)
        self.assertAlmostEqual(duty, expected, delta=100)

    def test_angle_mid(self):
        duty = angle_to_pwm(90)
        expected = int((1.5 / 20) * 65535)
        self.assertAlmostEqual(duty, expected, delta=100)

    def test_angle_max(self):
        duty = angle_to_pwm(180)
        expected = int((2 / 20) * 65535)
        self.assertAlmostEqual(duty, expected, delta=100)

    def test_angle_negative(self):
        duty = angle_to_pwm(-10)
        duty_zero = angle_to_pwm(0)
        self.assertEqual(duty, duty_zero)

    def test_angle_overflow(self):
        duty = angle_to_pwm(200)
        duty_max = angle_to_pwm(180)
        self.assertEqual(duty, duty_max)

    def test_move_servos_up(self):
        move_servos(90, 90, stylo_on=False)
        self.assertEqual(servo_epaule.duty_value, angle_to_pwm(90))
        self.assertEqual(servo_coude.duty_value, angle_to_pwm(90))
        self.assertEqual(servo_stylo.duty_value, angle_to_pwm(0))

    def test_move_servos_down(self):
        move_servos(90, 90, stylo_on=True)
        self.assertEqual(servo_epaule.duty_value, angle_to_pwm(90))
        self.assertEqual(servo_coude.duty_value, angle_to_pwm(90))
        self.assertEqual(servo_stylo.duty_value, angle_to_pwm(90))


# ============================
# MAIN
# ============================

if __name__ == "__main__":
    unittest.main()